<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GRPO Advantage Visualizer</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #60a5fa;
      --positive: #22c55e;
      --negative: #ef4444;
      --border: #1f2937;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(180deg, #0b1220 0%, var(--bg) 100%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .container {
      max-width: 1080px;
      margin: 24px auto;
      padding: 16px;
    }
    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px 16px;
      margin-bottom: 12px;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .control label {
      font-size: 12px;
      color: var(--muted);
    }
    .control input[type="number"] {
      background: #0b1220;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    .sliders {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 360px;
      overflow: auto;
      padding-right: 6px;
      margin-top: 8px;
    }
    .slider-row {
      display: grid;
      grid-template-columns: 120px 1fr 76px;
      align-items: center;
      gap: 10px;
    }
    .slider-row .name {
      color: var(--muted);
      font-size: 13px;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, #334155, #1f2937);
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0b1220;
      box-shadow: 0 2px 10px rgba(96,165,250,0.35);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0b1220;
      box-shadow: 0 2px 10px rgba(96,165,250,0.35);
      cursor: pointer;
    }
    .value-chip {
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
      color: #e2e8f0;
      background: #0b1220;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px 12px;
      margin-top: 12px;
      color: var(--muted);
      font-size: 13px;
    }
    .viz {
      margin-top: 16px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
    }
    .actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .btn {
      background: linear-gradient(180deg, #1f2937, #111827);
      color: #e5e7eb;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.03s ease-in-out, background 0.2s ease-in-out;
    }
    .btn:hover { background: linear-gradient(180deg, #2a3648, #141c2a); }
    .btn:active { transform: translateY(1px); }
    .note {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
    }
    a { color: var(--accent); text-decoration: none; }
  </style>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [["\\(", "\\)"]],
        displayMath: [["\\[", "\\]"]]
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!--
    GRPO advantage per group completion (commonly used):
      A_i = (r_i - mean(r)) / (std(r) + eps)
    When std == 0, all rewards are identical; we define all advantages as 0.
  -->
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>GRPO Advantage Visualizer</h1>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="control">
          <label for="numCompletions">Number of completions (n)</label>
          <input id="numCompletions" type="number" min="1" step="1" value="5" />
        </div>
        <div class="control">
          <label for="rewardMin">Reward slider min</label>
          <input id="rewardMin" type="number" step="0.01" value="-1" />
        </div>
        <div class="control">
          <label for="rewardMax">Reward slider max</label>
          <input id="rewardMax" type="number" step="0.01" value="1" />
        </div>
        <div class="control">
          <label for="epsilon">Epsilon (stability)</label>
          <input id="epsilon" type="number" step="1e-8" value="1e-8" />
        </div>
      </div>

      <div class="sliders" id="sliders"></div>

      <div class="stats" id="stats"></div>
      <div class="actions">
        <button id="resetBtn" class="btn" type="button">Reset rewards to 0</button>
        <button id="randomBtn" class="btn" type="button">Randomize rewards (Uniform)</button>
      </div>
    </div>

    <div class="viz">
      <div id="plot" style="width:100%;height:420px;"></div>
      <div class="note">
        Z-score variant: \(A_i = \dfrac{r_i - \bar{r}}{\sigma_r + \varepsilon}\). When \(\sigma_r = 0\), all advantages are set to 0.
      </div>

      <div id="plot_mean" style="width:100%;height:420px;margin-top:12px;"></div>
      <div class="note">
        Mean-centered variant: \(A_i = r_i - \bar{r}\) (no variance normalization).
      </div>
    </div>
  </div>

  <script>
    const slidersContainer = document.getElementById('sliders');
    const statsEl = document.getElementById('stats');
    const plotEl = document.getElementById('plot');
    const plotMeanEl = document.getElementById('plot_mean');

    const numEl = document.getElementById('numCompletions');
    const minEl = document.getElementById('rewardMin');
    const maxEl = document.getElementById('rewardMax');
    const epsEl = document.getElementById('epsilon');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function buildSliders(n) {
      slidersContainer.innerHTML = '';
      const minVal = Number(minEl.value);
      const maxVal = Number(maxEl.value);

      for (let i = 0; i < n; i++) {
        const row = document.createElement('div');
        row.className = 'slider-row';

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = `Completion ${i + 1}`;

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = String(minVal);
        slider.max = String(maxVal);
        slider.step = '0.01';
        slider.value = '0';
        slider.dataset.index = String(i);

        const chip = document.createElement('div');
        chip.className = 'value-chip';
        chip.textContent = '0.0';

        slider.addEventListener('input', () => {
          chip.textContent = Number(slider.value).toFixed(2);
          recomputeAndRender();
        });

        row.appendChild(name);
        row.appendChild(slider);
        row.appendChild(chip);
        slidersContainer.appendChild(row);
      }
    }

    function readRewards() {
      const sliders = slidersContainer.querySelectorAll('input[type="range"]');
      const rewards = [];
      sliders.forEach((slider) => {
        rewards.push(Number(slider.value));
      });
      return rewards;
    }

    function computeStats(values) {
      const n = values.length;
      if (n === 0) return { mean: 0, std: 0 };
      const mean = values.reduce((s, v) => s + v, 0) / n;
      const variance = values.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n; // population std
      const std = Math.sqrt(variance);
      return { mean, std };
    }

    function computeAdvantages(rewards, eps) {
      const { mean, std } = computeStats(rewards);
      if (!isFinite(eps) || eps <= 0) eps = 1e-8;
      const denom = std + eps;
      const zero = std === 0;
      const advantages = rewards.map((r) => (zero ? 0 : (r - mean) / denom));
      return { advantages, mean, std };
    }

    function renderStats(mean, std, rewards) {
      const minR = Math.min(...rewards);
      const maxR = Math.max(...rewards);
      const spread = maxR - minR;
      statsEl.innerHTML = `
        <div>\n<strong>Mean reward</strong>: ${mean.toFixed(4)}</div>
        <div>\n<strong>Std. dev.</strong>: ${std.toFixed(4)}</div>
        <div>\n<strong>Min reward</strong>: ${minR.toFixed(4)}</div>
        <div>\n<strong>Max reward</strong>: ${maxR.toFixed(4)}</div>
        <div>\n<strong>Range</strong>: ${spread.toFixed(4)}</div>
      `;
    }

    function renderPlot(advantages) {
      const n = advantages.length;
      const labels = Array.from({ length: n }, (_, i) => `C${i + 1}`);
      const colors = advantages.map((a) => (a >= 0 ? 'rgba(34,197,94,0.9)' : 'rgba(239,68,68,0.9)'));

      const maxAbs = Math.max(0.5, ...advantages.map((a) => Math.abs(a)));
      const yLim = Math.min(10, Math.ceil(maxAbs * 1.2 * 10) / 10);

      const trace = {
        x: labels,
        y: advantages,
        type: 'bar',
        marker: { color: colors },
        hovertemplate: 'Completion %{x}<br>Advantage: %{y:.4f}<extra></extra>'
      };

      const layout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        margin: { t: 36, r: 16, b: 48, l: 48 },
        title: { text: 'Per-completion Advantages (Z-Score)', font: { color: '#e5e7eb', size: 16 } },
        xaxis: {
          title: { text: 'Completions', font: { color: '#94a3b8' } },
          tickfont: { color: '#e5e7eb' },
          gridcolor: '#1f2937',
          zerolinecolor: '#1f2937'
        },
        yaxis: {
          title: { text: 'Advantage', font: { color: '#94a3b8' } },
          tickfont: { color: '#e5e7eb' },
          gridcolor: '#1f2937',
          zeroline: true,
          zerolinecolor: '#64748b',
          range: [-yLim, yLim]
        },
        showlegend: false
      };

      Plotly.newPlot(plotEl, [trace], layout, { displayModeBar: false, responsive: true });
    }

    function renderPlotMeanCentered(advantagesMean) {
      const n = advantagesMean.length;
      const labels = Array.from({ length: n }, (_, i) => `C${i + 1}`);
      const colors = advantagesMean.map((a) => (a >= 0 ? 'rgba(34,197,94,0.9)' : 'rgba(239,68,68,0.9)'));

      const maxAbs = Math.max(0.5, ...advantagesMean.map((a) => Math.abs(a)));
      const yLim = Math.min(10, Math.ceil(maxAbs * 1.2 * 100) / 100);

      const trace = {
        x: labels,
        y: advantagesMean,
        type: 'bar',
        marker: { color: colors },
        hovertemplate: 'Completion %{x}<br>Advantage (mean-centered): %{y:.4f}<extra></extra>'
      };

      const layout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        margin: { t: 36, r: 16, b: 48, l: 48 },
        title: { text: 'Per-completion Advantages (Mean-centered)', font: { color: '#e5e7eb', size: 16 } },
        xaxis: {
          title: { text: 'Completions', font: { color: '#94a3b8' } },
          tickfont: { color: '#e5e7eb' },
          gridcolor: '#1f2937',
          zerolinecolor: '#1f2937'
        },
        yaxis: {
          title: { text: 'Advantage', font: { color: '#94a3b8' } },
          tickfont: { color: '#e5e7eb' },
          gridcolor: '#1f2937',
          zeroline: true,
          zerolinecolor: '#64748b',
          range: [-yLim, yLim]
        },
        showlegend: false
      };

      Plotly.newPlot(plotMeanEl, [trace], layout, { displayModeBar: false, responsive: true });
    }

    function recomputeAndRender() {
      const rewards = readRewards();
      const eps = Number(epsEl.value);
      const { advantages, mean, std } = computeAdvantages(rewards, eps);
      const advantagesMeanCentered = rewards.map((r) => r - mean);
      renderStats(mean, std, rewards);
      renderPlot(advantages);
      renderPlotMeanCentered(advantagesMeanCentered);
    }

    function rebuildAndRender() {
      const n = Math.max(1, Math.floor(Number(numEl.value) || 1));
      const minVal = Number(minEl.value);
      const maxVal = Number(maxEl.value);
      if (!isFinite(minVal) || !isFinite(maxVal)) return;
      // clamp allowed reward range to [-1, 1]
      const clampedMin = Math.max(-1, Math.min(1, minVal));
      const clampedMax = Math.max(-1, Math.min(1, maxVal));
      minEl.value = String(clampedMin);
      maxEl.value = String(Math.max(clampedMax, clampedMin + 0.01));
      buildSliders(n);
      recomputeAndRender();
    }

    function resetAll() {
      const sliders = slidersContainer.querySelectorAll('input[type="range"]');
      sliders.forEach((sl) => {
        const minVal = Number(sl.min);
        const maxVal = Number(sl.max);
        const v = clamp(0, minVal, maxVal);
        sl.value = String(v);
        const chip = sl.nextElementSibling; // chip follows the slider in the row
        if (chip) chip.textContent = Number(sl.value).toFixed(2);
      });
      recomputeAndRender();
    }

    function randomizeAll() {
      const sliders = slidersContainer.querySelectorAll('input[type="range"]');
      sliders.forEach((sl) => {
        const minVal = Number(sl.min);
        const maxVal = Number(sl.max);
        const step = Number(sl.step) || 0.1;
        const raw = minVal + Math.random() * (maxVal - minVal);
        const quantized = Math.round(raw / step) * step;
        const v = clamp(quantized, minVal, maxVal);
        sl.value = String(v);
        const chip = sl.nextElementSibling;
        if (chip) chip.textContent = Number(sl.value).toFixed(2);
      });
      recomputeAndRender();
    }

    // Event bindings
    numEl.addEventListener('input', rebuildAndRender);
    minEl.addEventListener('change', () => {
      // update slider mins and clamp values
      let minVal = Math.max(-1, Math.min(1, Number(minEl.value)));
      let maxVal = Math.max(-1, Math.min(1, Number(maxEl.value)));
      if (maxVal <= minVal) maxVal = minVal + 0.01;
      minEl.value = String(minVal);
      maxEl.value = String(maxVal);
      slidersContainer.querySelectorAll('input[type="range"]').forEach((sl) => {
        sl.min = String(minVal);
        sl.value = String(clamp(Number(sl.value), minVal, maxVal));
        sl.dispatchEvent(new Event('input'));
      });
      recomputeAndRender();
    });
    maxEl.addEventListener('change', () => {
      let minVal = Math.max(-1, Math.min(1, Number(minEl.value)));
      let maxVal = Math.max(-1, Math.min(1, Number(maxEl.value)));
      if (maxVal <= minVal) maxVal = minVal + 0.01;
      minEl.value = String(minVal);
      maxEl.value = String(maxVal);
      slidersContainer.querySelectorAll('input[type="range"]').forEach((sl) => {
        sl.max = String(maxVal);
        sl.value = String(clamp(Number(sl.value), minVal, maxVal));
        sl.dispatchEvent(new Event('input'));
      });
      recomputeAndRender();
    });
    epsEl.addEventListener('input', recomputeAndRender);
    resetBtn.addEventListener('click', resetAll);
    randomBtn.addEventListener('click', randomizeAll);

    // Initialize
    rebuildAndRender();
  </script>
</body>
</html>


